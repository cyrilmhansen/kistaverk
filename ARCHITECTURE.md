# TECHNICAL ARCHITECTURE

## System Overview
The application follows a **Rendering Engine (Kotlin) <-> JNI Bridge <-> Core Logic (Rust)** model.

### 1. The UI Layer (Kotlin): "The Renderer"
There are no classic XML layout files for individual screens.
- **Single Activity:** `MainActivity` handles the global lifecycle.
- **UiRenderer:** A class that accepts JSON input and dynamically instantiates native Android `View` objects (LinearLayout, TextView, Button, etc.).
- **State Management:** A simple in-memory `Map<String, Any>` stores field values. The UI engine observes this Map to update the interface reactively.

### 2. The DSL Protocol (JSON)
Each screen is described by a JSON string generated by the Rust Core.
Typical structure:
```json
{
  "type": "Column",
  "children": [
    { "type": "Text", "bind_text": "status_msg" },
    { "type": "Button", "action": "do_compute" }
  ]
}

## 3. The Core Logic: "The Rust Fortress"
We utilize **Rust** as the native layer. It serves two purposes:
1.  **Safety & Performance:** It handles heavy lifting (PDF parsing, Crypto) with memory safety guarantees.
2.  **Orchestration:** It acts as the host for optional scripting.

### Layered Structure
1.  **JNI Interface (Rust):**
    *   Exposes a single entry point `extern "C" fn dispatch(...)` to Kotlin.
    *   Deserializes the JSON command.
2.  **Service Layer (Rust Modules):**
    *   Uses crates like `sha2` (Crypto), `lopdf` (PDF), `image` (Conversion).
    *   *Future Capability:* Can instantiate a **Lua VM** (via `mlua` crate) to run dynamic scripts if a task requires complex logic without recompilation.
3.  **Result:**
    *   Serializes output structs to JSON strings passed back to Android.

### Why this stack?
*   **Dependency Management:** `Cargo` handles cross-compilation for Android much better than CMake.
*   **Security:** Rust prevents memory corruption. Lua (if used) provides a sandboxed environment for logic execution.

## 4. The Core Logic (Rust)

Instead of C/C++, we choose **Rust** for the low-level core.
*   **Why?** Rust provides memory safety guarantees at compile-time without the runtime overhead of a Garbage Collector. It prevents entire classes of security vulnerabilities (buffer overflows) common in file manipulation tools.
*   **Toolchain:** Standard Android NDK with Rust support (Cargo-NDK).
*   **Structure:**
    *   The core is a Rust library compiled as a JNI `.so`.
    *   It handles strictly input/output operations (Files -> Hash/Result).
    *   Panic Strategy: The Rust core catches panics (`std::panic::catch_unwind`) and returns them as JSON error messages to the UI, preventing the App from crashing.

### Why not a Scripting Language (Lua/JS)?
To maintain the "Micro-tool" philosophy (< 5MB APK), we avoid embedding interpreters.
*   Scripting engines add runtime weight.
*   Rust offers high-level abstractions (like Python) but compiles down to efficient machine code.


### 5. UI Philosophy: "Backend-Driven UI"
We treat the Local Rust Core as a "Server" and the Android View as a "Client".
*   **Screen Construction:** Android never hardcodes screens. It requests the screen definition from Rust (e.g., `cmd: "get_home_screen"`).
*   **State updates:** When an action occurs, Rust returns the *entire new state description* of the UI (Virtual DOM style).
*   **Benefits:** Complex logic (e.g., "Show this specific error if SHA-256 fails but MD5 succeeds") resides solely in Rust.


-----

A. The Async/Threading Model
Since Rust cannot block the main thread, we must define an async boundary.
Recommended Strategy: "Kotlin-Side Async"
Kotlin: Uses Coroutines (Dispatchers.IO) to call the blocking Rust function.
Rust: Remains synchronous (simpler, smaller binary). It just calculates and returns.
UI: While waiting for Rust, Kotlin displays a loading spinner overlay (since the UI JSON hasn't returned yet).