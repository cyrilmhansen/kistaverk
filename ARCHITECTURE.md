# TECHNICAL ARCHITECTURE

## System Overview
The application follows a **Rendering Engine (Kotlin) <-> JNI Bridge <-> Core Logic (Rust)** model.

### 1. The UI Layer (Kotlin): "The Renderer"
There are no classic XML layout files for individual screens.
- **Single Activity:** `MainActivity` handles the global lifecycle and delegates rendering/navigation to JSON coming from Rust.
- **UiRenderer:** Accepts JSON from Rust and dynamically instantiates native Android `View` objects (LinearLayout, TextView, Button, ScrollView wrapper for Columns, plus a ShaderToy view).
- **Feature modules:** Feature-specific Kotlin code lives under `app/src/main/java/aeska/kistaverk/features` (e.g., Kotlin-side image conversion) so platform logic stays isolated from the activity.
- **Async boundary:** Blocking work runs on `Dispatchers.IO`; UI updates happen on the main thread after Rust returns JSON (or after Kotlin completes a local pipeline and reports the outcome back to Rust).
- **Media saves:** Image conversions default to MediaStore into `Pictures/kistaverk` (gallery-visible). A user-chosen SAF directory overrides this, with Rust still rendering the result screen.
- **Render fallback:** `MainActivity` catches `UiRenderer` errors and shows a minimal error screen (with a Back action), preventing renderer crashes from killing the app.
- **Inputs & bindings:** `UiRenderer` renders `TextInput` (EditText) widgets and forwards a `bindings` map with user-entered strings on every action; buttons still carry `requires_file_picker` hints for picker routing.
- **Accessibility:** JSON `content_description` is applied on Text, Button, Column, ShaderToy, and TextInput to cover TalkBack without XML layouts.

### 2. The DSL Protocol (JSON)
Each screen is described by a JSON string generated by the Rust Core.
Typical structure:
```json
{
  "type": "Column",
  "children": [
    { "type": "Text", "bind_text": "status_msg" },
    { "type": "Button", "action": "do_compute" }
  ]
}
```

With inputs/bindings:
```json
{
  "type": "Column",
  "children": [
    { "type": "TextInput", "bind_key": "text_input", "text": "hello", "hint": "Type text" },
    { "type": "Button", "action": "text_tools_upper" }
  ]
}
```
Actions from Kotlin now include the `bindings` map (key/value strings) so Rust can consume user input without parsing Android widgets.

## 3. The Core Logic: "The Rust Fortress"
We utilize **Rust** as the native layer. It serves two purposes:
1.  **Safety & Performance:** It handles heavy lifting (PDF parsing, Crypto) with memory safety guarantees.
2.  **Orchestration:** It owns navigation, state, and screen rendering even when a feature's heavy lifting runs on Kotlin (e.g., image conversion that reuses Android codecs).

### Layered Structure
1.  **JNI Interface (Rust):**
    *   Exposes a single entry point `extern "C" fn dispatch(...)` to Kotlin.
    *   Deserializes the JSON command.
2.  **Service Layer (Rust Modules):**
    *   Uses crates like `sha2` (Crypto) and future small modules as needed.
    *   Feature states and renderers live in their own modules (e.g., `features::hashes`, `features::kotlin_image`).
3.  **Result:**
    *   Serializes output structs to JSON strings passed back to Android.

### Why this stack?
*   **Dependency Management:** `Cargo` handles cross-compilation for Android much better than CMake.
*   **Security:** Rust prevents memory corruption. Lua (if used) provides a sandboxed environment for logic execution.

## 4. The Core Logic (Rust)

Instead of C/C++, we choose **Rust** for the low-level core.
*   **Why?** Rust provides memory safety guarantees at compile-time without the runtime overhead of a Garbage Collector. It prevents entire classes of security vulnerabilities (buffer overflows) common in file manipulation tools.
*   **Toolchain:** Standard Android NDK with Rust support (Cargo-NDK).
*   **Structure:**
    *   The core is a Rust library compiled as a JNI `.so`.
    *   It handles navigation, state, and pure-Rust features (streaming hashes) and also orchestrates screens whose heavy lifting happens in Kotlin (image conversion).
    *   Panic Strategy: The Rust core catches panics (`std::panic::catch_unwind`), recovers from poisoned state locks, and returns error JSON to the UI instead of crashing.
    *   Android build uses Gradle to call Cargo; cargo path is resolved from `CARGO` env or PATH (not hardcoded), keeping NDK/strip settings intact and building arm64-v8a only.
    *   Example: the Text Tools screen is rendered fully from Rust (TextInput + grouped action buttons for uppercase/lower/title/wrap/trim/count), and Kotlin simply renders native views and relays bindings.

### Why not a Scripting Language (Lua/JS)?
To maintain the "Micro-tool" philosophy (< 5MB APK), we avoid embedding interpreters.
*   Scripting engines add runtime weight.
*   Rust offers high-level abstractions (like Python) but compiles down to efficient machine code.


### 5. UI Philosophy: "Backend-Driven UI"
We treat the Local Rust Core as a "Server" and the Android View as a "Client".
*   **Screen Construction:** Android never hardcodes screens. It requests the screen definition from Rust (e.g., `cmd: "get_home_screen"`).
*   **State updates:** When an action occurs, Rust returns the *entire new state description* of the UI (Virtual DOM style). Kotlin-owned pipelines (like image conversion) run locally but immediately report results back through `dispatch` so Rust still drives the screen and navigation, including MediaStore/SAF target info.
*   **Benefits:** Complex logic (e.g., "Show this specific error if SHA-256 fails but MD5 succeeds") resides in Rust. Kotlin focuses on platform integrations, Android-provided codecs, and storage APIs (MediaStore/SAF).


-----

A. The Async/Threading Model
Since Rust cannot block the main thread, we must define an async boundary.
Recommended Strategy: "Kotlin-Side Async"
Kotlin: Uses Coroutines (Dispatchers.IO) to call the blocking Rust function.
Rust: Remains synchronous (simpler, smaller binary). It just calculates and returns.
UI: While waiting for Rust, Kotlin displays a loading spinner overlay (since the UI JSON hasn't returned yet).


A. State Serialization (The "Don't Lose My Work" Rule)
Android frequently kills background apps to save memory. When the user returns, MainActivity is recreated, but the Rust memory (the static Mutex) is wiped clean.
The Missing Protocol:
Serialize: On onSaveInstanceState (Kotlin), send a get_state_snapshot command to Rust. Rust serializes AppState to a JSON string or Byte Array and returns it. Kotlin saves this in the Bundle.
Restore: On onCreate (Kotlin), check if a Bundle exists. If yes, extract the snapshot and send restore_state(snapshot) to Rust.
Rust Impl: The AppState struct must derive Serialize and Deserialize.
B. The File Descriptor Bridge (Zero-Copy)
To solve the file copying issue mentioned in the feedback:
Mechanism:
Kotlin: Uses ContentResolver.openFileDescriptor(uri, "r").
JNI: Passes the int fd to Rust.
Rust:
code
Rust
use std::os::unix::io::FromRawFd;
use std::fs::File;

// UNSAFE: We must ensure Kotlin keeps the FD open while we read, 
// and that we don't double-close it if not intended.
let file = unsafe { File::from_raw_fd(fd) }; 
// Read file...
// std::mem::forget(file) // logic to prevent Rust from closing the FD if Kotlin owns it

C. Navigation & Feature Ownership
- **Screens:** `AppState` tracks the current screen (Home, Shader demo, Kotlin image flow). Feature state lives in dedicated modules under `features/` (e.g., `features::hashes`, `features::kotlin_image`).
- **Feature isolation:** Rust modules own state and rendering. Kotlin feature helpers own platform work (e.g., bitmap codecs) but send outcomes back through `dispatch`, so Rust drives UI and history.
- **Menu actions:** Buttons carry an `id` and `action`. Some actions open sub-screens (like the Kotlin image screen) and then request the picker; results flow back to Rust to render success/error, display chosen MediaStore/SAF targets, and keep navigation consistent.
